## Process digitizer data to get the beam current measured by Bergoz DCCT
#MON NSLS2 naming:[PSy[:PI]][-SSy[:SI]][-TSy[:TI]]{Dev[:DI]}[SgN[:SgI][-SgD]]
#### Psy	-	Primary system
#### Ssy	-	Secondary system
#### Dev	-	Device name
#### MON	-	BR-BI{DCCT:1}

#stored beam current at Booster and Ring
#Bergoz DCCT current is calibrated against gain settings 
#and Q offset (background noise)
#The RVAL and VAL of mbbi: [0, 15]; 
#use mbbo here: VAL--[0,15], RVAL--[0,65535] 
#record(mbbi, "${MON}FullScale-I")
record(mbbo, "${MON}FullScale-I")
{
  field(DESC,"scale: 20mA ~ 20000mA")
  field(DTYP,"Raw Soft Channel")
  #must use closed_loop
  field(OMSL, "closed_loop")
  #${MON}Range-Sel is in the ltb-plc IOC 
  field(DOL, "${MON}Range-Sel CP")
  field(ZRVL, "20000")
  field(ONVL, "2000")
  field(TWVL, "200")
  field(THVL, "20")
  field(ZRST, "20A")
  field(ONST, "2A")
  field(TWST, "200mA")
  field(THST, "20mA")
  field(FLNK, "${MON}IVSlope-Calc_")
}

record(calc,"${MON}IVSlope-Calc_")
{
   field(DESC,"slope:beam current/V")
   field(INPA,"${MON}FullScale-I.RVAL")
   field(INPB,"10.0")
   field(CALC,"A/B")
   field(PREC,"5")
   field(EGU,"mA/V")
   field(FLNK, "${MON}QVSlope-Calc_.PROC")
}

record(ao,"${MON}IOffset-SP")
{
   field(DESC,"beam current offset")
   field(PINI,"1")
   field(PREC,"3")
   field(EGU,"mA")
   info(autosaveFields_pass0, "VAL")
   field(FLNK,"BR-BI{DCCT:1}QOffset-I.PROC")
}

#${MON}IOffset-SP is based on AveI
record(calc,"${MON}AveI-I")
{
   field(DESC,"average current")
   field(INPA,"${MON}AveV-I CP")
   field(INPB,"${MON}IVSlope-Calc_")
   field(CALC,"A*B")
   field(PREC,"5")
   field(EGU,"mA")
   field(FLNK,"${MON}AveI-Com_")
}

record(compress,"${MON}AveI-Com_")
{
	field(DESC, "circular buffer of AveI")
	field(INP,  "${MON}AveI-I")
	field(ALG,	"Circular Buffer")
	field(NSAM, "10")
}

record(acalcout, "${MON}StdOverAveI-acalc_")
{
    field(DESC, "std of AveI")
    field(NELM, "10")
    field(INAA, "${MON}AveI-Com_ CP")
    field(CALC, "STD(AA)")
    field(NUSE, "10")
    field(OUT,  "${MON}StdOverAveI-I PP")
}

record(ai, "${MON}StdOverAveI-I")
{
	field(EGU, "mA")
}

record(acalcout,"${MON}I-aCalc_")
{
   field(DESC,"Beam current by DCCT")
   field(NELM,"100000")
   field(INAA,"${MON}V-Wf CP")
   field(INPA,"${MON}IVSlope-Calc_")
   field(INPB,"${MON}IOffset-SP")
   field(CALC,"ABS((A*AA)-B)")
   field(PREC,"3")
   field(EGU,"mA")
   field(NUSE,"100000")
   field(OUT,"${MON}I-Wf PP")
}

record(waveform,"${MON}I-Wf")
{
   field(DESC,"beam current waveform data")
   field(NELM,"100000")
   field(FTVL,"DOUBLE")
   field(PREC,"3")
   field(EGU,"mA")
}

record(calc,"${MON}AveQ-I")
{
   field(DESC,"average charge")
   field(INPA,"${MON}AveV-I CP")
   field(INPB,"${MON}QVSlope-Calc_")
   field(CALC,"A*B")
   field(PREC,"5")
   field(EGU,"nC")
}

record(acalcout,"${MON}Q-aCalc_")
{
   field(DESC,"Beam charge by DCCT")
   field(NELM,"100000")
   field(INAA,"${MON}V-Wf CP")
   field(INPA,"${MON}QVSlope-Calc_")
   field(INPB,"${MON}QOffset-I")
   field(CALC,"ABS((A*AA)-B)")
   field(PREC,"3")
   field(EGU,"nC")
   field(NUSE,"100000")
   field(OUT,"${MON}Q-Wf PP")
}

record(waveform,"${MON}Q-Wf")
{
   field(DESC,"beam charge waveform data")
   field(NELM,"100000")
   field(FTVL,"DOUBLE")
   field(PREC,"3")
   field(EGU,"nC")
}


#DCCT calibration current source is DC calibrator KH526 
record(calcout,"${MON}CalStatus-Calc_")
{
	field(DESC, "Is DC calibrator connected?")
	field(SCAN, "10 second")
	#4: 10mA; 5: 100mA
	field(INPA, "SR:C30-DI{KH526}Range-Sel")
	#field(INPB, "${MON}CalStatus-Calc_.STAT")
	#field(CALC, "A>3&&B==0")
	field(CALC, "A>3")
	field(OUT, "${MON}CalStatus-Sts PP")
	field(FLNK, "${MON}CalStatus-Calc2_")
}

record(calcout,"${MON}CalStatus-Calc2_")
{
	field(DESC, "Is DC calibrator connected?")
	field(INPA, "${MON}CalStatus-Calc_.STAT")
	field(CALC, "!(A>0)")
	field(OUT, "${MON}CalStatus-Sts PP")
}

record(bi, "${MON}CalStatus-Sts")
{
	field(DESC, "system status")
	field(ZNAM, "Not Ready")
	field(ONAM, "Ready")
}

record(mbbo, "${MON}StartCal-Sel")
{
	field(DESC, "start calibration")
	#field(OUT,  "${MON}Sweep-Calc_.DISA")
	field(ZRST, "Start")
	field(ONST, "Stop")
	field(VAL,  "1")
	field(FLNK, "$(MON)Reset-Seq")
}

record(seq, "$(MON)Reset-Seq")
{
  #Pay attention to the processing sequence of LNKn
  #DLY* of seq seems asynchronous;  
  field(DESC, "reset PVs")
  field(LNK1, "SR:C30-DI{KH526}Out-SP CA")
  field(LNK2, "${MON}Iterate-Calc_")
  field(LNK3, "${MON}Iterate-Calc_.DISA")
  field(LNK4, "${MON}Sweep-Calc_")
  #don't use PP for ${MON}CalInput-Wf_.RES, otherwise,
  #${MON}CalInput-Wf_ gets processed twice at the beginning  
  field(LNK5, "${MON}CalInput-Wf_.RES")
  #delay 4 seconds, then reset and process compress record
  #then, processing-loop starts
  field(DLY6, "4")
  field(LNK6, "${MON}CalOutput-Wf_.RES PP")
}

#sweep step size: FullScale*0.1/20; steps: 19 (0~18) 
#max. output value: 90%*0.1(due to DCCT windings)*FullScale
record(calcout,"${MON}Sweep-Calc_")
{
	field(DESC, "sweeping DC source")
	field(SDIS, "${MON}StartCal-Sel")
	field(INPA, "${MON}FullScale-I.RVAL")
	field(INPB, "20")
	field(INPC, "${MON}Sweep-Calc_")
	#INPD just for triggering record processing
	#It's OK to use any record type including waveform, compress	
	field(INPD, "${MON}CalOutput-Wf_ CP")
	field(CALC, "C<A*0.09?C+A*0.1/B:0")
	#field(CALC, "C+A*0.1/B")
	field(OOPT, "When Non-zero")
	#don't need PP for record.PROC
	field(OUT, "${MON}Delay-Calc_.PROC")
    field(FLNK, "${MON}SetCalibrator-SP")
}

record(ao, "${MON}SetCalibrator-SP")
{
	field(DESC, "write to DC Calibrator")
	field(OMSL, "closed_loop")
	field(DOL,	"${MON}Sweep-Calc_")
	field(OUT,  "SR:C30-DI{KH526}Out-SP CA")
}

#implementation of synchronous delay using calcout with ODLY and OUT to .PROC
record(calcout,"${MON}Delay-Calc_")
{
	field(DESC, "wait for the source stable")
	field(INPA, "${MON}Delay-Calc_")
	field(CALC, "!A")
	field(ODLY, "5")
	#be careful: ODLY doesn't delay the processing of FLNK
	#it's better to use OUT pointing to recordA.PROC to trigger recordA processed 
	field(OUT, "${MON}CalOutput-Wf_.PROC")
 	#field(FLNK, "${MON}CalOutput-Wf")
}

record(compress,"${MON}CalOutput-Wf_")
{
	field(DESC, "output data")
	field(INP,"${MON}AveI-I")
	field(ALG,"Circular Buffer")
	field(NSAM,"19")
	#FLNK seems not working for automatic loop-processing
	#field(FLNK,"${MON}Sweep-Calc_.PROC")
}

record(calc,"${MON}CalInput-Calc_")
{
	field(DESC, "DC source input")
	field(INPA, "${MON}Sweep-Calc_ CP")
	field(CALC, "A*10")
	field(FLNK, "${MON}CalInput-Wf_")
}

record(compress,"${MON}CalInput-Wf_")
{
	field(DESC, "DC source input")
	field(INP,"${MON}CalInput-Calc_")
	field(ALG,"Circular Buffer")
	field(NSAM,"19")
}

record(bo, "${MON}StartFit-Cmd")
{
	field(DESC, "start polyfit")
	field(ZNAM, "StopFit")
	field(ONAM, "StartFit")
	field(FLNK, "${MON}ShiftCalInput-acalc_")
}

record(acalcout,"${MON}ShiftCalInput-acalc_")
{
   field(DESC,"Right-shift of CalInput-Wf_")
   field(NELM,"19")
   field(INAA,"${MON}CalInput-Wf_")
   field(CALC,"AA>>1")
   field(NUSE,"19")
   field(OUT,"${MON}CalInput-Wf PP")
}

record(waveform,"${MON}CalInput-Wf")
{
   field(DESC,"DC source input")
   field(NELM,"19")
   field(FTVL,"DOUBLE")
   field(PREC,"1")
   field(EGU,"mA")
   field(FLNK,"${MON}CalOutput-Wf")
}

record(waveform,"${MON}CalOutput-Wf")
{
   field(DESC,"Readback data")
   field(NELM,"19")
   field(FTVL,"DOUBLE")
   field(PREC,"1")
   field(EGU,"mA")
   field(INP,"${MON}CalOutput-Wf_")
}

#First-order coefficients by python-based polyfit
record(ai, "${MON}CalP0-I")
{
    field(PREC, "6")
}

record(ai, "${MON}CalP1-I")
{ 
    field(PREC, "6")
}

record(calcout,"${MON}Iterate-Calc_")
{
	field(DESC, "iterate 19 times")
	field(DISV, "17")
	field(INPA, "${MON}Iterate-Calc_")
	#INPB just for triggering record processing; CP breaks lock-set
	field(INPB, "${MON}DelayFan-Calc_ CP")
	#field(INPB, "${MON}Delay-Calc_ CP")
	field(CALC, "A+1")
	#field(ODLY, "3")
	field(OUT,  "${MON}Iterate-Calc_.DISA")
	#field(FLNK, "${MON}Sweep-Calc_")
}

